1.  实现一个 ts 的工具函数 GetOnlyFnProps<T>

    提取泛型类型 T 中字段类型是函数的工具函数，其中 T 属于一个对象

    ```ts
    type GetOnlyFnProps<T extends object> = {
      [K in GetOnlyFnKeys<T>]: T[K];
    };
    type GetOnlyFnKeys<T extends object> = {
      [Key in keyof T]: T[K] extends Function ? K : never;
    };
    ```

2.  实现 readonly

    题目：构造一个类型，并将 T 的所有属性设置为只读，这意味着无法重新分配所构造类型的属性。

    ```ts
    interface Todo {
      title: string;
      description: string;
    }

    const todo: MyReadonly<Todo> = {
      title: "Hey",
      description: "foobar",
    };

    todo.title = "Hello"; // Error: cannot reassign a readonly property
    todo.description = "barFoo"; // Error: cannot reassign a readonly property
    ```

    ```ts
    type MyReadonly<T> = {
      readonly [S in keyof T]: T[S];
    };
    ```

3.  实现 pick

    题目：通过从 K 中选择属性 T 来构造类型

    ```ts
    interface Todo {
      title: string;
      description: string;
      completed: boolean;
    }

    type TodoPreview = MyPick<Todo, "title" | "completed">;

    const todo: TodoPreview = {
      title: "Clean room",
      completed: false,
    };
    ```

    ```ts
    type MyPick<T, K extends keyof T> = {
      [P in K]: T[P];
    };
    ```

4.  元组转换为对象

    题目：给定数组，转换为对象类型，键/值必须在给定数组中。

    ```ts
    const tuple = ["tesla", "model 3", "model X", "model Y"] as const;

    const result: TupleToObject<typeof tuple>; // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
    ```

    ```ts
    type TupleToObject<T extends readonly any[]> = {
      [K in T[number]]: K;
    };
    ```

5.  第一个数组元素的类型

    实现一个通用 First<T>，它接受一个数组 T 并返回它的第一个元素的类型。

    ```ts
    type arr1 = ["a", "b", "c"];
    type arr2 = [3, 2, 1];

    type head1 = First<arr1>; // expected to be 'a'
    type head2 = First<arr2>; // expected to be 3
    ```

    ```ts
    type First<T extends any[]> = T extends never[] ? never : T[0];
    ```

6.  获取元组长度

    对于给定的元组，您需要创建一个通用的 Length，选择元组的长度

    ```ts
    type tesla = ["tesla", "model 3", "model X", "model Y"];
    type spaceX = [
      "FALCON 9",
      "FALCON HEAVY",
      "DRAGON",
      "STARSHIP",
      "HUMAN SPACEFLIGHT"
    ];

    type teslaLength = Length<tesla>; // expected 4
    type spaceXLength = Length<spaceX>; // expected 5
    ```

    ```ts
    type Length<T extends readonly any[]> = T["length"];
    ```

7.  Exclude

    实现内置的 Exclude <T，U>，从 T 中排除可分配给 U 的那些类型

    ```ts
    type x = string | number | boolean;

    type y = string | number;

    type c = MyExclude<x, y>;

    const b: c = true;
    ```

    ```ts
    type MyExclude<T, U> = T extends U ? never : T;
    ```

8.  我们有 Promise<ExampleType> 如何获得 ExampleType？

    ```ts
    type b = Promise<string>;

    const c: Awaited<b> = "";
    ```

    ```ts
    type Awaited<T extends Promise<unknown>> = T extends Promise<infer R>
      ? R
      : never;
    ```

9.  If

    实现一个工具类型，它接受条件 c 为 true 或 false，c 为 true 返回 T，c 为 false 返回 U。

    ```ts
    type A = If<true, "a", "b">; // expected to be 'a'
    type B = If<false, "a", "b">; // expected to be 'b'
    ```

    ```ts
    type If<C extends boolean, T, U> = C extends true ? T : U;
    ```

10. Array.concat

    ```ts
    type Result = Concat<[1], [2]>; // expected to be [1, 2]
    ```

    ```ts
    type Concat<T extends any[], U extends any[]> = [...T, ...U];
    ```

11. Array.includes

    ```ts
    type isPillarMen = Includes<["Kars", "Esidisi", "Wamuu", "Santana"], "Dio">; // expected to be `false`
    ```

    ```ts
    type Includes<T extends readonly any[], U> = U extends T[number]
      ? true
      : false;
    ```

12. infer 推断,判断 resolve 里的类型

    infer 是一个非常强大的关键字，可以在 extends 条件语句中待推断的类型变量，听起来糊里糊涂。

    这里来举个小栗子:
    平时我们可以通过 ReturnType 获取函数的返回值，但是如果函数返回的是一个 Promise 对象，这时候我们又想获取这个结果的类型，该怎么处理

    ```ts
    function fn() {
      return Promise.resolve(1);
    }

    type PromiseType<T extends Promise<any>> = T extends Promise<infer R>
      ? R
      : any;

    type FnReturnType = PromiseType<ReturnType<typeof fn>>;
    ```

    这里的 infer R 就是推断，我简单的理解就是他首先要在 extends 语句中使用，然后代替语句后的某一个部分(参数、返回值、泛型等)，然后用表达式判断如果推断的出来就返回，如果不行则返回 any(也有喜欢用 never 的)

13. 获取函数返回类型

    题目：不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 范型。

    ```ts
    const fn = (v: boolean) => {
      if (v) return 1;
      else return 2;
    };

    type a = MyReturnType<typeof fn>; // 应推导出 "1 | 2"
    ```

    ```ts
    type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
    ```

14. 实现 Omit

    不使用 Omit 实现 TypeScript 的 Omit<T, K> 范型。Omit 会创建一个省略 K 中字段的 T 对象。

    ```ts
    interface Todo {
      title: string;
      description: string;
      completed: boolean;
    }

    type TodoPreview = MyOmit<Todo, "description" | "title">;

    const todo: TodoPreview = {
      completed: false,
    };
    ```

    ```ts
    type MyOmit<T, U extends keyof T> = {
      [P in Exclude<keyof T, U>]: T[P];
    };
    ```

15. 实现 Readonly 2

    题目：实现一个通用 MyReadonly2<T, K>，它带有两种类型的参数 T 和 K。

    K 指定应设置为 Readonly 的 T 的属性集。如果未提供 K，则应使所有属性都变为只读，就像普通的 Readonly<T>一样。

    ```ts
    interface Todo {
      title: string;
      description: string;
      completed: boolean;
    }

    const todo: MyReadonly2<Todo, "title" | "description"> = {
      title: "Hey",
      description: "foobar",
      completed: false,
    };

    todo.title = "Hello"; // Error: cannot reassign a readonly property
    todo.description = "barFoo"; // Error: cannot reassign a readonly property
    todo.completed = true; // OK
    ```

    ```ts
    type MyReadonly2<T, K extends keyof T> = {
      readonly [P in K]: T[P];
    } &
      {
        [P in Exclude<keyof T, K>]: T[P];
      };
    ```

16. 深度 Readonly
    题目：实现一个通用的 DeepReadonly<T>，它将对象的每个参数及其子对象递归地设为只读。

    您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

    ```ts
    type X = {
      x: {
        a: 1;
        b: "hi";
      };
      y: "hey";
    };

    type Expected = {
      readonly x: {
        readonly a: 1;
        readonly b: "hi";
      };
      readonly y: "hey";
    };

    const todo: DeepReadonly<X>; // should be same as `Expected`
    ```

    ```ts
    type DeepReadonly<T> = {
      readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
    };
    ```

17. 元组转合集
    实现泛型 TupleToUnion<T>，它覆盖元组的值与其值联合。

    ```ts
    type Arr = ["1", "2", "3"];

    const a: TupleToUnion<Arr>; // expected to be '1' | '2' | '3'
    ```

    ```ts
    type TupleToUnion<T extends any[]> = T[number];
    ```

18. 可串联构造器
    题目：在 JavaScript 中我们很常会使用可串联（Chainable/Pipeline）的函数构造一个对象，但在 TypeScript 中，你能合理的给他附上类型吗？

    在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - Interface, Type 或 Class 都行。你需要提供两个函数 option(key, value) 和 get()。在 option 中你需要使用提供的 key 和 value 扩展当前的对象类型，通过 get 获取最终结果。

    你只需要在类型层面实现这个功能 - 不需要实现任何 TS/JS 的实际逻辑。

    你可以假设 key 只接受字符串而 value 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。同样的 key 只会被使用一次。

    ```ts
    declare const config: Chainable;

    const result = config
      .option("foo", 123)
      .option("name", "type-challenges")
      .option("bar", { value: "Hello World" })
      .get();

    // 期望 result 的类型是：
    interface Result {
      foo: number;
      name: string;
      bar: {
        value: string;
      };
    }
    ```

    ```ts
    type Chainable<T> = {
      option<P extends string, K>(
        key: P,
        value: K
      ): Chainable<T & { [U in P]: K }>;
      get(): T;
    };
    ```

19. 最后一个元素
    题目：实现一个通用 Last<T>，它接受一个数组 T 并返回其最后一个元素的类型。

    ```ts
    type arr1 = ["a", "b", "c", "d"];
    type arr2 = [3, 2, 1];

    type tail1 = Last<arr1>; // expected to be 'c'
    type tail2 = Last<arr2>; // expected to be 1
    ```

    ```ts
    type arr1 = ["a", "b", "c", "d"];
    type arr2 = [3, 2, 1];

    type Last<T> = T extends [...any[], infer P] ? P : never;
    ```

20. 出堆
    题目：实现一个通用 Pop<T>，它接受一个数组 T 并返回一个没有最后一个元素的数组。

    ```ts
    type arr1 = ["a", "b", "c", "d"];
    type arr2 = [3, 2, 1];

    type re1 = Pop<arr1>; // expected to be ['a', 'b', 'c']
    type re2 = Pop<arr2>; // expected to be [3, 2]
    ```

    ```ts
    type Pop<T> = T extends [...infer U, infer P] ? U : never;
    ```

21. Promise.all
    题目：键入函数 PromiseAll，它接受 PromiseLike 对象数组，返回值应为 Promise<T>，其中 T 是解析的结果数组。

    ```ts
    const promise1 = Promise.resolve(3);
    const promise2 = 42;
    const promise3 = new Promise<string>((resolve, reject) => {
      setTimeout(resolve, 100, "foo");
    });

    // expected to be `Promise<[number, number, string]>`
    const p = PromiseAll([promise1, promise2, promise3] as const);
    ```

    ```ts
    declare function PromiseAll<T extends readonly any[]>(
      values: readonly [...T]
    ): Promise<
      {
        [P in keyof T]: T[P] extends Promise<infer R> ? R : T[P];
      }
    >;
    ```

22. 有时，您可能希望根据其属性在并集中查找类型。

    在此挑战中，我们想通过在联合 Cat | Dog 中搜索公共 type 字段来获取相应的类型。换句话说，在以下示例中，我们期望 LookUp<Dog | Cat, 'dog'>获得 Dog，LookUp<Dog | Cat, 'cat'>获得 Cat。

    ```ts
    interface Cat {
      type: "cat";
      breeds: "Abyssinian" | "Shorthair" | "Curl" | "Bengal";
    }

    interface Dog {
      type: "dog";
      breeds: "Hound" | "Brittany" | "Bulldog" | "Boxer";
      color: "brown" | "white" | "black";
    }

    type MyDog = LookUp<Cat | Dog, "dog">; // expected to be `Dog`
    ```

    ```ts
    type LookUp<T, U extends string> = T extends { type: U } ? T : never;
    ```

23. 删除字符串开头的空格

    ```ts
    type trimed = TrimLeft<"  Hello World  ">; // expected to be 'Hello World  '
    ```

    ```ts
    type TrimLeft<T> = T extends `${" " | "\n" | "\t"}${infer R}` ? TrimLeft<R> : T;
    ```

24. 删除字符串开头和结尾的空格

    ```ts
    type trimed = Trim<"  Hello World  ">; // expected to be 'Hello World'
    ```

    ```ts
    type Trim<T> = T extends `${" " | "\n" | "\t"}${infer R}${" " | "\n" | "\t"}` ? Trim<R> : T;
    ```

25. 将第一个字符转为大写

    ```ts
    type capitalized = Capitalize<"hello world">; // expected to be 'Hello world'
    ```

    ```ts
    type MyCapitalize<T> = T extends `${infer P}${infer U}`
    ? `${Uppercase<P>}${U}`
    : T;
    ```

26. 替换给定的内容

    ```ts
    type replaced = Replace<"types are fun!", "fun", "awesome">; // expected to be 'types are awesome!'
    ```

    ```ts
      type Replace<
    T extends string,
    U extends string,
    P extends string
    > = U extends ""
    ? T
    : T extends `${infer A}${U}${infer B}`
    ? `${A}${P}${B}`
    : T;
    ```

27. 替换全部给定的内容

    ```ts
    type replaced = ReplaceAll<"t y p e s", " ", "">; // expected to be 'types'
    ```

    ```ts
    type ReplaceAll<
    T extends string,
    U extends string,
    P extends string
    > = U extends ""
    ? T
    : T extends `${infer R}${U}${infer K}`
    ? ReplaceAll<`${R}${P}${K}`, U, P>
    : T;
    ```

28. 追加参数
    题目：实现一个范型 AppendArgument<Fn, A>，对于给定的函数类型 Fn，以及一个任意类型 A，返回一个新的函数 G。G 拥有 Fn 的所有参数并在末尾追加类型为 A 的参数。

    ```ts
    type Fn = (a: number, b: string) => number;

    type Result = AppendArgument<Fn, boolean>;
    // 期望是 (a: number, b: string, x: boolean) => number
    ```

    ```ts
    type AppendArgument<T, A> = T extends (...args: infer P) => infer R
      ? (...args: [...P, A]) => R
      : never;
    ```

29. 计算字符串的长度

    ```ts
    type a = "hellow world";

    type b = LengthOfString<a>; // type b = 12
    ```

    ```ts
    type LengthOfString<
      T extends string,
      U extends any[] = []
    > = T extends `${infer R}${infer K}`
      ? LengthOfString<K, [...U, R]>
      : U["length"];
    ```

30. 铺平数组

    ```ts
    type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]>; // [1, 2, 3, 4, 5]
    ```

    ```ts
    type Flatten<T extends any[]> = T extends [infer R, ...infer K]
      ? R extends any[]
        ? [...Flatten<R>, ...Flatten<K>]
        : [R, ...Flatten<K>]
      : T;
    ```

31. 拓展对象的属性

    ```ts
    type Test = { id: "1" };
    type Result = AppendToObject<Test, "value", 4>; // expected to be { id: '1', value: 4 }
    ```

    ```ts
    type AppendToObject<T extends object, U extends string, K> = {
      [P in keyof T | U]: P extends keyof T ? T[P] : K;
    };
    ```

32. 获取数字的绝对值，返回绝对值的字符串形式

    ```ts
    type Test = -100;
    type Result = Absolute<Test>; // expected to be "100"
    ```

    ```ts
    type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}`
    ? R
    : `${T}`;
    ```

33. 合并两个类型，key 相同的类型由第二个覆盖第一个

    ```ts
    type a = {
      x: 1;
      y: 3;
    };

    type b = {
      y: 2;
      z: 3;
    };

    type c = Merge<a, b>; // c { x: 1, y: 2, z: 3 }
    ```

    ```ts
    type Merge<T, U> = {
      [P in keyof T | keyof U]: P extends keyof U
        ? U[P]
        : P extends keyof T
        ? T[P]
        : never;
    };
    ```

34. 将 横杠式 for-bar-baz 改为 驼峰式 forBarBaz

    ```ts
    type a = "for-bar-baz";

    type b = CamelCase<a>; // forBarBaz
    ```

    ```ts
    type CamelCase<T extends string> = T extends `${infer R}-${infer U}${infer K}`
      ? CamelCase<`${R}${Uppercase<U>}${K}`>
      : T;
    ```
