编写一个高效的算法来搜索 `_m_ x _n_` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。
![[Pasted image 20260219233308.png]]

```js
/**

* @param {number[][]} matrix

* @param {number} target

* @return {boolean}

*/

var searchMatrix = function (matrix, target) {
  if (!matrix || !matrix.length) return false

  // 行数

  const m = matrix.length

  // 列数

  const n = matrix[0].length

  // 从右上角开始搜索

  // 初始化行列位置

  let row = 0

  // 初始化行列位置

  let col = n - 1

  while (row < m && col >= 0) {
    const cur = matrix[row][col]

    if (cur === target) {
      return true
    } else if (cur < target) {
      row++
    } else if (cur > target) {
      col--
    }
  }

  return false
}

console.log(
  searchMatrix(
    [
      [1, 4, 7, 11, 15],
      [2, 5, 8, 12, 19],
      [3, 6, 9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30],
    ],
    5
  )
)

```

## 最优解的核心思路：从右上角（或左下角）开始“走”

这个矩阵是「行有序 + 列有序」，我们要利用这个性质，让每一步比较都能**排除一整行或一整列**，而不是一个一个点去看。

### 1. 为啥选右上角？

设当前点为 `matrix[row][col]`，当我们从**右上角**开始时：

- 在它的**左边**（同一行，列变小）：值一定都 **更小**
- 在它的**下面**（同一列，行变大）：值一定都 **更大**

假设当前值为 `x = matrix[row][col]`，有三种情况：

1. `x === target`：找到，结束
2. `x > target`：
    - 因为当前列从上到下递增，而我们现在已经在当前列的最上方之一
    - 下面的值只会更大
    - 所以整列往下都不可能是 target
    - **只能往左移动一列**：`col--`
3. `x < target`：
    - 因为当前行从左到右递增，而我们在最右边之一
    - 左边的值只会更小
    - 所以这一行往左都不可能是 target
    - **只能往下移动一行**：`row++`

这样，每一步要么「去掉一列」，要么「去掉一行」，非常高效。

### 2. 搜索的终止条件

从右上角一路向左或向下走：

- 行下标 `row` 最多从 `0` 走到 `m - 1`
- 列下标 `col` 最多从 `n - 1` 走到 `0`

当出现：

- `row >= m`（走到矩阵下面去了）或者
- `col < 0`（走到最左边左侧去了）

说明所有可能的位置都已经排除，还没找到 `target`，返回 `false`。