给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
```
**示例 1:**

**输入:** s = "cbaebabacd", p = "abc"
**输出:** [0,6]
**解释:**
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

 **示例 2:**

**输入:** s = "abab", p = "ab"
**输出:** [0,1,2]
**解释:**
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

```
var findAnagrams = function(s, p) {

let res = []

// 统计s中每个字符的出现次数

let sCount = new Array(26).fill(0)

// 统计p中每个字符的出现次数

let pCount = new Array(26).fill(0)

const sLen = s.length

const pLen = p.length

// 临界：如果s的长度小于p的长度，则不可能存在异位词，直接返回空数组

if (sLen < pLen) return res

for(let i = 0; i<pLen; i++) {

pCount[p.charCodeAt(i) - 'a'.charCodeAt()]++

}

let left = 0

for(let right = 0; right<sLen; right++) {

sCount[s.charCodeAt(right) - 'a'.charCodeAt()]++

if (right - left + 1 > pLen) {

sCount[s.charCodeAt(left) - 'a'.charCodeAt()]--

left++

}

// 重点：sCount.toString() === pCount.toString() 等价于每个字母计数逐一相等，因此可判定为异位。

console.log(sCount.toString(), pCount.toString())

if (sCount.toString() === pCount.toString()) {

res.push(left)

}

}

return res

};
```