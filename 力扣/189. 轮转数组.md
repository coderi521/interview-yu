给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
```
**示例 1:**

**输入:** nums = [1,2,3,4,5,6,7], k = 3
**输出:** `[5,6,7,1,2,3,4]`
**解释:**
向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：**nums = [-1,-100,3,99], k = 2
**输出：**[3,99,-1,-100]
**解释:** 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

```js
/**

* @param {number[]} nums

* @param {number} k

* @return {void} Do not return anything, modify nums in-place instead.

*/

var rotate = function(nums, k) {

const length = nums.length

const newK = k % length

if (newK === 0) return nums // 整数轮， [1,2] k= 2 2%2 = 0 反转之后跟之前相等

reverse(nums, 0, length - 1)

reverse(nums, 0, newK - 1)

reverse(nums, newK, length- 1)

return nums

};

  

function reverse(arr, start, end) {

while(start < end) {

[arr[start], arr[end]] = [arr[end], arr[start]]

start++

end--

}

return arr

}
```

- **时间复杂度：O(n)**  
    整个过程就是 3 次线性反转，每次 O(n)，常数很小，总体还是 O(n)。
- **空间复杂度：O(1)**  
    全程原地交换，只用到几个临时变量，不需要额外数组。
- 如果 `k` 比数组还大，比如长度 `n = 7`，`k = 10`，  
    向右转 10 步，和向右转 `10 % 7 = 3` 步是一样的。
- 如果 `k % n === 0`，说明转了一整圈或多圈，数组不变，直接返回即可。
- 向右旋转 k 步”的本质效果是：

- **后面 k 个元素** 移到前面来
- **前面 n−k 个元素** 移到后面去

以例子 `nums = [1,2,3,4,5,6,7], k = 3` 为例：

- 后段（要搬到前面）：`[5,6,7]`
- 前段（要搬到后面）：`[1,2,3,4]`
- 目标结果：`[5,6,7,1,2,3,4]`

反转法的“魔法”在于：

1. **整体反转**：  
    `原始: [1,2,3,4,5,6,7]`  
    → 反转整个数组 → `[7,6,5,4,3,2,1]`
2. **反转前 k 个**（原来后段的逆序）：  
    `[7,6,5,4,3,2,1]`  
    → 反转前 3 个 → `[5,6,7,4,3,2,1]`
3. **反转后 n-k 个**（原来前段的逆序）：  
    `[5,6,7,4,3,2,1]`  
    → 反转从索引 3 到 6 → `[5,6,7,1,2,3,4]`

这就达到了“把后段搬到前面、前段搬到后面”的目标，且顺序是对的。

> 可以这么记：
> 
> - “先大反，再小反，再小反”
> - 全部 → 前半 → 后半