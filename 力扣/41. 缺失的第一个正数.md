给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

```
**示例 1：**

**输入：**nums = [1,2,0]
**输出：**3
**解释：**范围 [1,2] 中的数字都在数组中。

**示例 2：**

**输入：**nums = [3,4,-1,1]
**输出：**2
**解释：**1 在数组中，但 2 没有。

**示例 3：**

**输入：**nums = [7,8,9,11,12]
**输出：**1
**解释：**最小的正数 1 没有出现。
```

```js
/**

* @param {number[]} nums

* @return {number}

*/

var firstMissingPositive = function (nums) {
  const n = nums.length

  for (let i = 0; i < n; i++) {
    const vaule = nums[i]

    while (vaule > 0 && vaule <= n && nums[i] !== nums[nums[i] - 1]) {
      const targetIndex = nums[i] - 1 // 当前i对应的value 应该在的位置

      // 互换位置

      const temp = nums[i]

      nums[i] = nums[targetIndex]

      nums[targetIndex] = temp
    }
  }

  for (let i = 0; i < n; i++) {
    if (nums[i] !== i + 1) {
      return i + 1
    }
  }

  return n + 1
}

```

## 核心思路（原地哈希 / 原地“放回正确位置”）

### 1. 非正式直观理解

**数组长度为 n 时：答案一定在 `[1, n+1]` 之间。​**

- 如果数组中刚好包含 `1, 2, ..., n`，那么缺失的第一个正数就是 `n+1`
- 否则，在 `1 ~ n` 这个区间中必然有一个数缺失

于是：

- 我们**只关心 1 ~ n 的数字**
- 目标是：**尽量把数字 k 放到索引 k-1 的位置**
    - 例如：1 → 索引 0
    - 2 → 索引 1
    - 3 → 索引 2
    - ...

**如果最后检查时，某个索引 i 不是 `i+1`，那么说明 `i+1` 这个数缺了。​**