给定两个字符串 `s` 和 `t`，长度分别是 `m` 和 `n`，返回 s 中的 **最短窗口 子串**，使得该子串包含 `t` 中的每一个字符（**包括重复字符**）。如果没有这样的子串，返回空字符串 `""`。

测试用例保证答案唯一。
```
**示例 1：**

**输入：**s = "ADOBECODEBANC", t = "ABC"
**输出：**"BANC"
**解释：**最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

**示例 2：**

**输入：**s = "a", t = "a"
**输出：**"a"
**解释：**整个字符串 s 是最小覆盖子串。

**示例 3:**

**输入:** s = "a", t = "aa"
**输出:** ""
**解释:** t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```
```
/**

* @param {string} s

* @param {string} t

* @return {string}

*/

var minWindow = function(s, t) {

if (s.length < t.length) return "" // 如果s的长度小于t的长度，说明不可能有覆盖子串，直接返回空字符串

let minLen = Infinity // 初始化为最大值

let map = {} // 记录下每个字母出现的次数

let missType = 0 // 记录缺少的字符种类数

for(const i of t) {

if (!map[i]) { // 如果没有这个字符，说明缺少了一个种类

map[i] = 1 // 记录这个字符出现的次数

missType++ // 缺少的字符种类数加1

} else {

map[i]++ // 如果有这个字符，说明缺少的这个种类的数量增加了

}

}

let left = 0 // 左指针

let right = 0 // 右指针

let start = 0 // 记录最小覆盖子串的起始位置

for(; right<s.length; right++) { // 右指针

let rightChar = s[right] // 右指针指向的字符

if (map[rightChar] !== undefined) { // 如果这个字符在t中，说明缺少的这个种类的数量减少了

map[rightChar] -- // 记录这个字符出现的次数

}

if (map[rightChar] === 0) { // 如果这个字符的数量为0，说明缺少的这个种类的数量减少了

missType-- // 缺少的字符种类数减1

}

while(missType === 0) { // 当缺少的字符种类数为0，说明找到了一个覆盖子串

if (right - left + 1 < minLen) { // 如果这个覆盖子串的长度小于最小覆盖子串的长度，更新最小覆盖子串的长度和起始位置

minLen = right - left + 1 // 更新最小覆盖子串的长度

start = left // 更新最小覆盖子串的起始位置

}

// 下边是移动左指针，缩小窗口的过程： 所以会把missType增加，直到missType不为0，说明这个窗口不再是覆盖子串了

let leftChar = s[left] // 左指针指向的字符

if (map[leftChar] !== undefined) { // 如果这个字符在t中，说明缺少的这个种类的数量增加了

map[leftChar]++ // 记录这个字符出现的次数

}

if (map[leftChar] > 0) { // 如果这个字符的数量大于0，说明缺少的这个种类的数量增加了

missType++ // 缺少的字符种类数加1

}

left++

}

}

return minLen === Infinity ? "" : s.substring(start, start+minLen)

};

console.log(minWindow("ADOBECODEBANC", "ABC"))
```

https://www.bilibili.com/video/BV1eV411C7s2/?spm_id_from=333.337.search-card.all.click&vd_source=f7e2c865c4051a81751841e06b0facb1
