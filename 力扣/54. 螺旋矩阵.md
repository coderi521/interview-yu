给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```
**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]
**输出：**[1,2,3,6,9,8,7,4,5]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

**输入：**matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
**输出：**[1,2,3,4,8,12,11,10,9,5,6,7]
```

```js
/**

* @param {number[][]} matrix

* @return {number[]}

*/

var spiralOrder = function (matrix) {
  // 处理空矩阵的情况，直接返回空数组

  if (!matrix || matrix.length === 0) return []

  const m = matrix.length // 行数

  const n = matrix[0].length // 列数

  const result = [] // 最终按螺旋顺序返回的数组

  // 使用四个边界来控制遍历范围：上(top)、下(bottom)、左(left)、右(right)

  // 初始时，top = 0, bottom = m-1, left = 0, right = n-1

  // 每遍历完一条边，就把对应边界收缩一格，直到边界交叉为止

  let top = 0

  let bottom = m - 1

  let left = 0

  let right = n - 1

  // 循环条件为左右边界和上下边界未交叉

  while (top <= bottom && left <= right) {
    // 1) 从左到右遍历上边（row = top）

    for (let col = left; col <= right; col++) {
      result.push(matrix[top][col])
    }

    top++ // 上边已遍历，向下收缩

    // 2) 从上到下遍历右边（col = right）

    for (let row = top; row <= bottom; row++) {
      result.push(matrix[row][right])
    }

    right-- // 右边已遍历，向左收缩

    // 3) 注意：在收缩边界后，需要判断是否仍然满足遍历条件

    // 如果 top > bottom 或 left > right，则说明已经遍历完所有元素

    if (top > bottom || left > right) break

    // 4) 从右到左遍历下边（row = bottom）

    for (let col = right; col >= left; col--) {
      result.push(matrix[bottom][col])
    }

    bottom-- // 下边已遍历，向上收缩

    // 5) 从下到上遍历左边（col = left）

    for (let row = bottom; row >= top; row--) {
      result.push(matrix[row][left])
    }

    left++ // 左边已遍历，向右收缩
  }

  return result
}

```

用四个指针来表示当前还没遍历过的“外框”：

- `top`：当前还没遍历过区域的**上边界行索引**
- `bottom`：下边界行索引
- `left`：左边界列索引
- `right`：右边界列索引

遍历顺序固定为一圈一圈地走：

1. 上边：从左到右
2. 右边：从上到下
3. 下边：从右到左
4. 左边：从下到上

每走完一条边，就把相应的边界“收缩”一格，直到所有元素都取完。

时间复杂度：遍历每个元素一次，**O(m × n)**  
空间复杂度：除结果数组外只用常数额外变量，**O(1)**（结果数组是题目要求的输出，不算额外空间）