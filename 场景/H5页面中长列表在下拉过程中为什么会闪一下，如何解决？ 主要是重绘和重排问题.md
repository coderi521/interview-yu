```
### 1. 浏览器层面：频繁重排（reflow）+ 重绘（repaint）

下拉长列表时，滚动会触发：

1. JS 逻辑（滚动监听、虚拟列表计算、懒加载等）
2. DOM 结构 / 样式变化
3. 浏览器重新：
    - 计算布局（重排）
    - 重新绘制像素（重绘）

如果下面这些情况出现，就容易在一帧内做大量重排/重绘，导致**内容短暂消失或位置跳动，看起来像“闪一下”**：

- 列表项高度在滚动过程中发生变化（图片加载、文字换行、动态展开/收起等）
- 使用 `top/left/height/margin` 等属性做动画或定位，频繁触发布局计算
- 一次性渲染/更新大量 DOM 节点（几百上千个 item）
- 滚动事件回调里频繁读写布局信息（`offsetTop`, `clientHeight` 等），造成 layout thrashing
  
### 2. 长列表 / 虚拟列表特有的问题

很多 H5 为了长列表性能，会上“虚拟列表”（只渲染可视区附近的元素），这类实现如果细节没处理好，也会导致闪烁：

1. **可视区域计算不稳定**  
    例如用 `scrollTop / itemHeight` 算可见索引，如果 `itemHeight` 和真实高度不一致，就会出现**上一帧和下一帧渲染范围抖动**，列表像在“呼吸”。
    
2. **滚动锚定（scroll anchoring）导致的抖动**  
    现代浏览器有滚动锚定机制，会自动尝试保持“视口中某个元素”的可见位置不变。  
    虚拟列表/懒加载时不断插入/删除 DOM，浏览器在“锚定”和“布局更新”之间反复调整滚动位置，造成轻微跳动 / 闪烁。
    
3. **没有足够的缓冲区**  
    虚拟列表刚好只渲染一屏内容，用户快速滑动时，上一屏刚移出，可视区还没来得及渲染新节点，会出现瞬时空白 / 闪一下。

## 二、如何解决 / 缓解闪烁问题？

可以从 CSS 层、JS 实现层两方面回答，面试时挑重点说即可。

### （一）CSS 层面的优化

#### 1. 禁用滚动锚定：`overflow-anchor: none`

很多“滚动到一半突然跳一下”的闪动，直接是滚动锚定造成的。
/* 列表外层容器 */
.list-container {
  overflow-y: auto;
  overflow-anchor: none;   /* 关键：禁用滚动锚定 */
}

#### 2. 尽量用 `transform` 替代会触发布局的属性

- 不要用 `top/left/height/margin` 做滚动中动画或位移；
- 用 `transform: translate/translate3d`：
  /* 不推荐：触发布局 */
.item-moving {
  top: 10px;
}

/* 推荐：只触发合成，不重排 */
.item-moving {
  transform: translateY(10px);
}

#### 3. 尽量让列表项高度“稳定”

- 对纯文本列表：直接**固定高度**，避免因为一两行变成两三行导致 item 高度在滚动过程中变化。
- 对有图片的列表：
    - 先用固定高度占位（例如根据宽高比计算一个占位框），图片加载完成再填充；
    - 避免加载完成后突然撑高 item。

### （二）JS / 实现层面的优化

#### 1. 使用成熟的虚拟列表库或正确实现虚拟列表

思路要点：

- **只渲染可视区 + 上下各若干 buffer 项**，避免频繁创建/销毁大量 DOM；
- 假设固定高度：用 `scrollTop / itemHeight` 算起始索引；
- 总高度用一层占位容器撑起来，内部再用 `transform: translateY(offset)` 位移真实可见 DOM。

简单伪代码（思想即可）：
#### 2. 滚动事件节流 / 使用 `requestAnimationFrame`

let rafId = null;
container.addEventListener('scroll', () => {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(() => {
    // 这里再去计算可视区、更新虚拟列表
  });
}, { passive: true });

#### 批量 DOM 更新，避免 layout thrashing

- 多个样式修改尽量合并后一次性修改；
- 避免以下模式：
  
  // 错误示例：循环中一边读一边写布局，容易频繁强制同步布局
for (...) {
  const h = el.offsetHeight;  // 读
  el.style.height = (h + 10) + 'px';  // 写
}
先读完再写，或缓存布局信息
假设我要更新一个元素的颜色、宽度、高度，应该把 const ele.hight = xxpx ele.color = 'red' 最后再更新真实dom
```